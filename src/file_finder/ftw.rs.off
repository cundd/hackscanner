extern crate libc;

use std::ffi::CStr;
use std::ffi::CString;
use self::libc::c_char;
use self::libc::c_int;
use self::libc::stat;

use std::path::Path;
use std::path::PathBuf;
use std::fmt::Debug;
//use std::sync::Arc;
use std::sync::{Arc, Mutex, MutexGuard};
use std::sync::RwLock;

use std::vec::Vec;

use super::FileFinderTrait;
use dir_entry::StandaloneDirEntry;


static LOCK: RwLock<bool> = RwLock::new(true);
static mut FOUND_PATHS: Arc<Option<Vec<String>>> = Arc::new(None);


//static mut LOCK: Arc<Mutex<u8>> = Arc::new(Mutex::new(0));
//static mut FOUND_PATHS: Arc<Mutex<Option<Vec<String>>>> = Arc::new(Mutex::new(None));


//let mut tmp: *mut c_char = 0 as *mut c_char;
//pub type WalkFn = extern fn(fpath:*mut c_char, const struct stat *sb, typeflag:c_int)
type WalkFn = extern fn(fpath: *const c_char, sb: *const stat, typeflag: c_int) -> c_int;


//static mut ARC: Arc<Vec<String>> = Arc::new(vec![]);

// int ftw(
//          const char *dirpath,
//          int (*fn) (const char *fpath, const struct stat *sb, int typeflag),
//          int nopenfd
// );
extern {
    fn ftw(dirpath: *const c_char, f: WalkFn, nopenfd: c_int) -> c_int;
}


extern fn x(fpath: *const c_char, sb: *const stat, typeflag: c_int) -> c_int {
    unsafe {
        let path_string = CStr::from_ptr(fpath);
//        let paths: Option<Vec<String>> = *FOUND_PATHS;

        match *FOUND_PATHS {
            Some(ref mut p) => p.push(path_string.to_string_lossy().into_owned()),
            None => panic!("FOUND_PATHS is None")
        }
    }

    0
}


pub struct FileFinder {}

impl FileFinderTrait for FileFinder {
    type DirEntry = StandaloneDirEntry;
    fn walk_dir<P: AsRef<Path> + Debug + Clone, F>(root: P, filter: F) -> Vec<Self::DirEntry>
        where F: FnMut(&Self::DirEntry) -> bool {
        let entries = collect_dir_entries(root);

        entries.into_iter().filter(filter).collect()
    }
}

fn collect_dir_entries<P: AsRef<Path> + Debug + Clone>(root: P) -> Vec<StandaloneDirEntry> {
    unsafe {
        match *FOUND_PATHS {
            None => FOUND_PATHS = Arc::new(Some(vec![])),
            Some(_) => {}
        }
    }
    let path_as_string = root.as_ref().to_string_lossy().into_owned();
    unsafe {
        ftw(CString::new(path_as_string).unwrap().as_ptr(), x, 20);
    }

    unsafe {
        match *FOUND_PATHS {
            Some(ref mut p) => p.iter().
                filter_map(|path| {
                    StandaloneDirEntry::from_path(PathBuf::from(path)).ok()
                }).collect(),
            None => panic!("FOUND_PATHS is None")
        }


//        match FOUND_PATHS {
//            Some(ref mut paths) => paths.
//                iter().
//                filter_map(|path| {
//                    StandaloneDirEntry::from_path(PathBuf::from(path)).ok()
//                }).collect(),
//            None => vec![]
//        }
    }
}

#[cfg(test)]
mod test {
    use super::*;


    #[test]
    fn walk_dir_test() {

//        let w :WalkFn = |fpath: *mut c_char, sb: *const stat, typeflag: c_int| {};
//            let tmp: *mut libc::c_char = std::ptr::null();
        let r = FileFinder::walk_dir("/Users/daniel/Sites/Projects/hackscanner", |_| true);
//            println!("{:#?}", r);
    }

    #[test]
    fn find_test() {

//        let w :WalkFn = |fpath: *mut c_char, sb: *const stat, typeflag: c_int| {};
//            let tmp: *mut libc::c_char = std::ptr::null();
        let r = FileFinder::walk_dir("/Users/daniel/Sites/Projects/hackscanner", |_| true);
//            println!("{:#?}", r);
    }
}

//int ftw(const char *dirpath,
//int (*fn) (const char *fpath, const struct stat *sb,
//int typeflag),
//int nopenfd);

//fn signal(signal: c_int, sighandler_t: SignalHandlerFn) -> SignalHandlerFn;
//}
//
//pub fn register(signal_code: Signal, callback: SignalHandlerFn) {
//unsafe {
//signal(signal_code as c_int, callback);
//}
//}
